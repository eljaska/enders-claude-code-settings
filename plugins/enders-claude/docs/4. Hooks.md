# 4. Hooks - Deterministic Automation

## Overview

Hooks are user-defined shell commands that execute automatically at specific points during Claude Code's lifecycle. Unlike CLAUDE.md instructions (which Claude may or may not follow), hooks are **guaranteed to execute**, providing deterministic control over Claude's behavior.

**Think of them as**: Event-driven automation - your custom scripts that run automatically when specific things happen.

**Key characteristics**:
- Execute shell commands at lifecycle events
- Can block or modify tool execution
- Guaranteed execution (not LLM-dependent)
- Configured in JSON format
- Can add context or validation
- Support both command and prompt types

## Key Concepts

### Hooks vs. Other Features

| Feature | Execution | Conditional | Use Case |
|---------|-----------|-------------|----------|
| **Hooks** | Guaranteed | Event-based | Auto-format, validation, logging |
| **CLAUDE.md** | Advisory | Always loaded | Instructions, context |
| **Skills** | On-demand | User/Claude | Workflows, domain knowledge |
| **Subagents** | Delegated | Claude decides | Specialized tasks |

### Hook Types

**Command Hooks**: Execute shell commands
```json
{
  "type": "command",
  "command": "prettier --write $FILE"
}
```

**Prompt Hooks**: LLM-based evaluation (deprecated, use command hooks)
```json
{
  "type": "prompt",
  "prompt": "Is this file safe to edit?"
}
```

### Hook Events

Claude Code provides 11+ hook events:

| Event | When It Fires | Can Block? | Common Use Cases |
|-------|--------------|------------|------------------|
| **PreToolUse** | Before tool execution | Yes (exit 2) | Validation, blocking, modification |
| **PostToolUse** | After tool succeeds | No | Auto-format, tests, logging |
| **PostToolUseFailure** | After tool fails | No | Error handling, cleanup |
| **PermissionRequest** | Permission dialog appears | Yes | Auto-allow/deny |
| **UserPromptSubmit** | User submits prompt | Yes | Add context, validate |
| **Notification** | Claude sends notification | No | Desktop alerts |
| **Stop** | Claude finishes | No | Cleanup, logging |
| **SubagentStop** | Subagent completes | No | Result processing |
| **PreCompact** | Before context compression | No | Save state |
| **Setup** | Repository initialization | No | Project setup |
| **SessionStart** | Session begins/resumes | No | Initialization |
| **SessionEnd** | Session terminates | No | Cleanup |

## How It Works

### Execution Flow

```
Event Occurs (e.g., Claude calls Edit tool)
  ↓
PreToolUse hooks fire
  ↓
Hooks execute in parallel
  ↓
Check exit codes:
  - Exit 0: Success, continue
  - Exit 2: Block with error message
  - Other: Warning, continue
  ↓
Tool executes (if not blocked)
  ↓
PostToolUse hooks fire
  ↓
Continue
```

### Exit Codes

| Exit Code | Meaning | Effect |
|-----------|---------|--------|
| 0 | Success | Continue normally |
| 2 | Block | Stop tool execution, show error |
| Other | Warning | Log warning, continue |

### Hook Input

Hooks receive tool information via:

**stdin**: JSON object with tool details
```json
{
  "tool_name": "Edit",
  "tool_input": {
    "file_path": "/path/to/file.ts",
    "old_string": "...",
    "new_string": "..."
  }
}
```

**Environment variable**: `$@` contains same JSON

**Parsing example**:
```bash
FILE=$(jq -r '.tool_input.file_path' <<< "$@")
```

## Configuration

### File Locations

| Location | Scope | Priority |
|----------|-------|----------|
| `.claude/settings.json` | Project (shared) | High |
| `.claude/settings.local.json` | Project (personal) | Higher |
| `~/.claude/settings.json` | User (all projects) | Lower |

### Basic Structure

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "echo 'File modified' >> /tmp/log.txt",
            "timeout": 30
          }
        ]
      }
    ]
  }
}
```

### Configuration Fields

#### Hook Configuration

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `matcher` | string | No | Tool pattern (case-sensitive), `*` or `""` for all |
| `hooks` | array | Yes | List of hook objects |
| `once` | boolean | No | Execute only once per session |

#### Hook Object

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `type` | string | Yes | - | "command" or "prompt" |
| `command` | string | Yes (command) | - | Shell command to execute |
| `prompt` | string | Yes (prompt) | - | Prompt for LLM evaluation |
| `timeout` | number | No | 60 | Timeout in seconds (max 600) |

### Matchers

Match tools by name:

```json
"matcher": "Edit"          // Matches Edit tool only
"matcher": "Edit|Write"    // Matches Edit OR Write
"matcher": "Bash"          // Matches Bash tool
"matcher": "*"             // Matches all tools
"matcher": ""              // Matches all tools
```

**Case-sensitive**: `"Edit"` ≠ `"edit"`

## Usage Patterns

### Basic Usage

#### Example 1: Auto-Format on Save

**Purpose**: Automatically format files after editing.

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path' <<< \"$@\"); if [[ $FILE == *.ts || $FILE == *.tsx || $FILE == *.js || $FILE == *.jsx ]]; then npx prettier --write \"$FILE\" 2>/dev/null || true; fi"
          }
        ]
      }
    ]
  }
}
```

#### Example 2: Block Sensitive File Edits

**Purpose**: Prevent Claude from editing `.env` files or lock files.

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "python3 -c \"import json, sys; data=json.load(sys.stdin); path=data.get('tool_input',{}).get('file_path',''); blocked=['.env', 'package-lock.json', 'yarn.lock', '.git/', 'node_modules/']; sys.exit(2) if any(b in path for b in blocked) else sys.exit(0)\""
          }
        ]
      }
    ]
  }
}
```

#### Example 3: Run Tests After Changes

**Purpose**: Run related tests when code changes.

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path' <<< \"$@\"); if [[ $FILE == src/*.java ]]; then TEST=$(basename \"$FILE\" .java)Test; ./mvnw test -Dtest=\"$TEST\" 2>/dev/null || true; fi",
            "timeout": 120
          }
        ]
      }
    ]
  }
}
```

### Advanced Usage

#### Example 4: Trino Java Auto-Format

**Purpose**: Run Spotless formatter on Java files automatically.

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path' <<< \"$@\"); if [[ $FILE == *.java ]]; then ./mvnw spotless:apply -DspotlessFiles=\"$FILE\" 2>&1 | grep -v '\\[INFO\\]' || true; fi",
            "timeout": 60
          }
        ]
      }
    ]
  }
}
```

#### Example 5: Audit Logging

**Purpose**: Log all bash commands for compliance.

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S'); COMMAND=$(jq -r '.tool_input.command' <<< \"$@\"); echo \"[$TIMESTAMP] $COMMAND\" >> ~/.claude/audit.log"
          }
        ]
      }
    ]
  }
}
```

#### Example 6: Add Context on Every Prompt

**Purpose**: Inject current git branch into every user prompt.

```json
{
  "hooks": {
    "UserPromptSubmit": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "BRANCH=$(git branch --show-current 2>/dev/null); if [ -n \"$BRANCH\" ]; then echo \"Current branch: $BRANCH\"; fi"
          }
        ]
      }
    ]
  }
}
```

#### Example 7: Desktop Notifications

**Purpose**: Get notified when Claude needs input.

```json
{
  "hooks": {
    "Notification": [
      {
        "matcher": "permission_prompt",
        "hooks": [
          {
            "type": "command",
            "command": "if command -v notify-send &> /dev/null; then notify-send 'Claude Code' 'Awaiting your input' --urgency=normal; fi"
          }
        ]
      }
    ]
  }
}
```

#### Example 8: Validate Migrations

**Purpose**: Validate SQL migrations before creation.

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path' <<< \"$@\"); if [[ $FILE == migrations/*.sql ]]; then ./scripts/validate-migration.sh \"$FILE\"; fi",
            "timeout": 30
          }
        ]
      }
    ]
  }
}
```

#### Example 9: Type Check TypeScript

**Purpose**: Run TypeScript type checker after edits.

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path' <<< \"$@\"); if [[ $FILE == *.ts || $FILE == *.tsx ]]; then npx tsc --noEmit \"$FILE\" 2>&1 | head -20 || true; fi",
            "timeout": 30
          }
        ]
      }
    ]
  }
}
```

## Examples

### Complete Hook Configurations

#### Example: Full Development Setup

**File**: `.claude/settings.json`

```json
{
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "python3 -c \"import json, sys; data=json.load(sys.stdin); path=data.get('tool_input',{}).get('file_path',''); blocked=['.env', '.git/', 'package-lock.json', 'yarn.lock', 'pnpm-lock.yaml']; sys.exit(2) if any(b in path for b in blocked) else sys.exit(0)\""
          }
        ]
      },
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "COMMAND=$(jq -r '.tool_input.command' <<< \"$@\"); echo \"[$(date)] $COMMAND\" >> ~/.claude/bash-audit.log"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path' <<< \"$@\"); case \"$FILE\" in *.ts|*.tsx|*.js|*.jsx) npx prettier --write \"$FILE\" 2>/dev/null || true ;; *.java) ./mvnw spotless:apply -DspotlessFiles=\"$FILE\" 2>/dev/null | grep -v '\\[INFO\\]' || true ;; *.py) black \"$FILE\" 2>/dev/null || true ;; esac",
            "timeout": 60
          }
        ]
      }
    ],
    "UserPromptSubmit": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "BRANCH=$(git branch --show-current 2>/dev/null); [ -n \"$BRANCH\" ] && echo \"Branch: $BRANCH\""
          }
        ]
      }
    ],
    "SessionEnd": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "echo \"[$(date)] Session ended\" >> ~/.claude/session.log"
          }
        ]
      }
    ]
  }
}
```

## Best Practices

### Security

1. **Validate all inputs**: Never trust input data
   ```bash
   # Bad
   FILE=$@
   rm $FILE

   # Good
   FILE=$(jq -r '.tool_input.file_path' <<< "$@")
   if [[ "$FILE" == /* ]] && [[ ! "$FILE" =~ \.\. ]]; then
     rm "$FILE"
   fi
   ```

2. **Quote variables**: Prevent injection
   ```bash
   # Bad
   command $VAR

   # Good
   command "$VAR"
   ```

3. **Check for path traversal**: Block `..` in paths
   ```bash
   if [[ "$FILE" =~ \.\. ]]; then
     exit 2
   fi
   ```

4. **Avoid wildcards in matchers**: Be specific
   ```json
   // Bad
   "matcher": "*"

   // Good
   "matcher": "Edit|Write"
   ```

5. **Use absolute paths**: For scripts and commands
   ```bash
   # Bad
   ./validate.sh

   # Good
   /full/path/to/validate.sh
   # or
   "$CLAUDE_PROJECT_DIR/scripts/validate.sh"
   ```

### Performance

1. **Keep hooks fast**: Use appropriate timeouts
   ```json
   {
     "command": "quick-check",
     "timeout": 5
   }
   ```

2. **Run long operations in background**: Don't block
   ```bash
   npx prettier --write "$FILE" &
   ```

3. **Limit output**: Avoid overwhelming logs
   ```bash
   command 2>&1 | head -20
   ```

4. **Use conditional checks**: Don't run unnecessarily
   ```bash
   if [[ $FILE == *.ts ]]; then
     npx tsc --noEmit "$FILE"
   fi
   ```

### Maintainability

1. **Use external scripts**: For complex logic
   ```json
   {
     "command": "$CLAUDE_PROJECT_DIR/scripts/validate.sh"
   }
   ```

2. **Document hooks**: Add comments in settings
   ```json
   {
     "_comment": "Auto-format TypeScript/JavaScript files",
     "matcher": "Edit|Write",
     ...
   }
   ```

3. **Test hooks manually**: Before deploying
   ```bash
   # Test the command directly
   echo '{"tool_input":{"file_path":"test.ts"}}' | bash -c 'your-command'
   ```

4. **Use appropriate scope**: User vs project vs local
   - User: Personal utilities (all projects)
   - Project: Team-shared (committed)
   - Local: Personal overrides (not committed)

## Common Patterns

### Pattern 1: Language-Specific Formatting

```json
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "hooks": [
          {
            "type": "command",
            "command": "FILE=$(jq -r '.tool_input.file_path' <<< \"$@\"); case \"$FILE\" in *.py) black \"$FILE\" 2>/dev/null || true ;; *.go) gofmt -w \"$FILE\" 2>/dev/null || true ;; *.rs) rustfmt \"$FILE\" 2>/dev/null || true ;; esac"
          }
        ]
      }
    ]
  }
}
```

### Pattern 2: Conditional Hook Execution

```bash
# Only run in CI environment
if [ "$CI" = "true" ]; then
  run-strict-validation
else
  run-lenient-validation
fi
```

### Pattern 3: Deduplication

```bash
# Use lock file to prevent duplicate execution
LOCK="/tmp/hook-$$.lock"
if [ ! -f "$LOCK" ]; then
  touch "$LOCK"
  execute-hook
  rm "$LOCK"
fi
```

### Pattern 4: Graceful Failure

```bash
# Always exit 0 unless you want to block
command-that-might-fail 2>/dev/null || true
```

## Gotchas and Troubleshooting

### Common Issues

#### Issue 1: Hook Not Firing

**Symptoms**: Hook doesn't execute

**Causes**:
- Matcher doesn't match tool name (case-sensitive)
- Hook in wrong event
- Configuration not reloaded

**Solutions**:
```bash
# Check exact tool name (case matters)
"matcher": "Edit"  # NOT "edit"

# Verify event
"PreToolUse" not "PreTool"

# Restart session to reload config
exit
claude
```

#### Issue 2: Hook Blocks Unexpectedly

**Symptoms**: Tool execution blocked

**Cause**: Exit code 2 returned

**Solution**: Check hook command exit code
```bash
# Debug
echo '{"tool_input":{"file_path":"test.ts"}}' | your-command
echo $?  # Should be 0
```

#### Issue 3: File Path Not Found

**Symptoms**: Hook fails with "file not found"

**Cause**: Parsing error or wrong field

**Solution**: Use correct jq path
```bash
# Correct
FILE=$(jq -r '.tool_input.file_path' <<< "$@")

# Handle missing field
FILE=$(jq -r '.tool_input.file_path // empty' <<< "$@")
```

#### Issue 4: Timeout

**Symptoms**: Hook killed after timeout

**Cause**: Command takes too long

**Solution**: Increase timeout or run in background
```json
{
  "command": "long-running-command",
  "timeout": 300
}
```

#### Issue 5: Permission Denied

**Symptoms**: Hook fails with permission error

**Cause**: Script not executable

**Solution**:
```bash
chmod +x /path/to/script.sh
```

### Debugging

**Enable verbose output**:
```bash
set -x  # At top of hook script
command
set +x
```

**Test hook manually**:
```bash
echo '{"tool_name":"Edit","tool_input":{"file_path":"test.ts"}}' | bash -c 'YOUR_HOOK_COMMAND'
```

**Check logs**:
```bash
# Add logging to hook
echo "Hook fired: $(date)" >> /tmp/hook-debug.log
```

### Limitations

1. **No hook chaining**: Hooks run in parallel, not sequentially
2. **Limited context**: Only receive tool information, not conversation
3. **No return values**: Can't modify tool input (except via exit codes)
4. **Session restart required**: Config changes need restart
5. **Bash tracking not supported**: Hooks can't undo bash command file changes

## API Reference

### Hook Events

| Event | Trigger | Blocking | Input |
|-------|---------|----------|-------|
| `PreToolUse` | Before tool execution | Yes | Tool name, tool input |
| `PostToolUse` | After tool succeeds | No | Tool name, tool input, result |
| `PostToolUseFailure` | After tool fails | No | Tool name, tool input, error |
| `PermissionRequest` | Permission dialog | Yes | Permission details |
| `UserPromptSubmit` | User submits prompt | Yes | User prompt text |
| `Notification` | Claude notification | No | Notification details |
| `Stop` | Claude finishes | No | Session info |
| `SubagentStop` | Subagent completes | No | Agent info, results |
| `PreCompact` | Before compaction | No | Context size |
| `Setup` | Repo initialization | No | Project info |
| `SessionStart` | Session begins | No | Session info |
| `SessionEnd` | Session ends | No | Session info |

### Exit Codes

| Code | Name | Effect |
|------|------|--------|
| 0 | Success | Continue normally |
| 2 | Block | Stop operation, show error to user |
| Other | Warning | Log warning, continue |

### Environment Variables

Available in hook execution:

| Variable | Description |
|----------|-------------|
| `$@` | JSON string with tool information |
| `$CLAUDE_PROJECT_DIR` | Project root directory |
| `$CLAUDE_SESSION_ID` | Current session ID |

## Related Features

### CLAUDE.md
Hooks enforce rules from CLAUDE.md. Use CLAUDE.md for instructions, Hooks for enforcement.

### Skills
Skills can define hooks in frontmatter. Use for skill-specific validation.

### Subagents
Agents can define hooks in frontmatter. Use for agent-specific controls.

## Additional Resources

- **Hook Examples**: https://github.com/anthropics/claude-code-hooks
- **Official Documentation**: https://docs.anthropic.com/claude/docs/claude-code-hooks
- **Community Hooks**: https://github.com/topics/claude-hooks

---

**Next**: Learn about [MCP](./5.%20MCP.md) to connect external tools and services.
