# 1. CLAUDE.md - Persistent Memory

## Overview

CLAUDE.md is Claude Code's persistent memory system - a special markdown file that Claude reads at the start of every conversation. It stores context that doesn't change between sessions, things Claude can't infer from code alone.

**Think of it as**: Long-term memory for your project, bridging the gap between what's in your code and what you want Claude to know.

**Key characteristics**:
- Read automatically at session startup
- Applies to all conversations in that project
- Written in markdown with optional YAML frontmatter
- Supports hierarchical loading (user-level, project-level, local)
- Can import other files for modular organization

## Key Concepts

### Memory vs. Conversation

| Conversation | CLAUDE.md Memory |
|--------------|------------------|
| Ephemeral (resets each session) | Persistent (loaded every session) |
| User messages and Claude responses | Instructions, conventions, context |
| Specific to current task | Applies to all tasks in project |
| Disappears after `/clear` | Survives session resets |

### Memory Hierarchy

Claude Code loads CLAUDE.md files recursively, starting from your working directory and moving up to the root. This creates a hierarchy where more specific contexts override general ones:

```
~/.claude/CLAUDE.md                    # Personal preferences (all projects)
  ↓ overridden by
~/Developer/my-project/.claude/CLAUDE.md   # Project-wide (shared with team)
  ↓ overridden by
~/Developer/my-project/.claude/rules/      # Modular project rules
  ↓ overridden by
~/Developer/my-project/CLAUDE.local.md     # Personal project overrides (not committed)
```

**Priority order** (highest to lowest):
1. Local personal overrides (`CLAUDE.local.md` or `.claude/CLAUDE.local.md`)
2. Project-level rules (`.claude/rules/*.md`)
3. Project-level memory (`.claude/CLAUDE.md` or `CLAUDE.md`)
4. Parent directory CLAUDE.md files (recursive)
5. User-level memory (`~/.claude/CLAUDE.md`)

### Scope Types

| Location | File | Scope | Committed? | Use Case |
|----------|------|-------|------------|----------|
| **User Global** | `~/.claude/CLAUDE.md` | All your projects | No | Personal preferences, universal conventions |
| **Project** | `.claude/CLAUDE.md` or `CLAUDE.md` | Current project | Yes | Team-shared context, project conventions |
| **Local** | `CLAUDE.local.md` or `.claude/CLAUDE.local.md` | Current project (personal) | No | Personal project-specific overrides |
| **Modular** | `.claude/rules/*.md` | Current project | Yes | Organized by topic (code-style, testing, etc.) |

## How It Works

### Loading Process

1. **Session starts** - User runs `claude` or `claude --continue`
2. **Discover files** - Claude walks directory tree from cwd to root
3. **Read files** - Loads all CLAUDE.md files in hierarchy
4. **Process imports** - Resolves `@path/to/file.md` references
5. **Apply priority** - Higher-priority locations override lower
6. **Add to context** - Content included in every conversation

### When CLAUDE.md is Loaded

- ✅ New sessions (`claude`)
- ✅ Resumed sessions (`claude --continue`)
- ✅ After `/memory` edits
- ❌ Mid-conversation (requires restart or `/memory` reload)

### Import Syntax

CLAUDE.md supports importing external files using `@path/to/file`:

```markdown
See @README.md for project overview and @package.json for available commands.

# Additional Instructions
@docs/git-workflow.md
@~/.claude/java-style-guide.md
```

**Import resolution**:
- Relative paths: Relative to the CLAUDE.md file containing the import
- Absolute paths: Start with `/` or `~/`
- Tilde expansion: `~` expands to user home directory

**Circular imports**: Prevented automatically (Claude stops after detecting cycles)

### Modular Rules

For large projects, organize instructions into topic-specific files in `.claude/rules/`:

```
.claude/rules/
├── code-style.md
├── testing.md
├── security.md
├── git-workflow.md
└── frontend/
    ├── react.md
    └── styles.md
```

All `.md` files in `.claude/rules/` are automatically loaded and merged.

### Conditional Rules

Use YAML frontmatter to apply rules only to matching files:

```markdown
---
paths:
  - "src/**/*.ts"
  - "src/**/*.tsx"
---

# TypeScript/React Rules
- Use functional components with hooks
- Prefer named exports
- Always include PropTypes or TypeScript interfaces
```

**Frontmatter fields**:
- `paths`: Glob patterns for files this rule applies to
- `description`: Optional description of the rule's purpose

## Configuration

### File Locations

#### User-Level Configuration
```bash
~/.claude/CLAUDE.md
```

**Purpose**: Personal preferences applied to all projects.

**Examples**: Git commit style, editor preferences, communication style.

**Setup**:
```bash
mkdir -p ~/.claude
nano ~/.claude/CLAUDE.md
```

#### Project-Level Configuration
```bash
# Option 1: Project root
./CLAUDE.md

# Option 2: .claude directory (recommended)
./.claude/CLAUDE.md
```

**Purpose**: Team-shared project context.

**Examples**: Code style, build commands, architecture decisions.

**Setup**:
```bash
mkdir -p .claude
nano .claude/CLAUDE.md
git add .claude/CLAUDE.md
```

#### Local Project Configuration
```bash
# Option 1: Project root
./CLAUDE.local.md

# Option 2: .claude directory
./.claude/CLAUDE.local.md
```

**Purpose**: Personal project-specific overrides (not shared with team).

**Examples**: Local environment setup, personal shortcuts.

**Setup**:
```bash
nano .claude/CLAUDE.local.md
echo ".claude/CLAUDE.local.md" >> .gitignore
echo "CLAUDE.local.md" >> .gitignore
```

#### Modular Rules Directory
```bash
./.claude/rules/
```

**Purpose**: Organized topic-specific rules.

**Examples**: `code-style.md`, `testing.md`, `security.md`.

**Setup**:
```bash
mkdir -p .claude/rules
nano .claude/rules/code-style.md
git add .claude/rules/
```

### Format Guidelines

#### Basic Structure

```markdown
# Section Title

Brief description of what this section covers.

## Subsection

- Bullet points for clarity
- Concrete examples
- Specific instructions

## Another Subsection

More organized instructions.
```

#### Best Format Practices

**Do:**
```markdown
## Git Commits

Follow Chris Beams guidelines:
1. Subject line: 50 chars max, imperative mood
2. Separate subject and body with blank line
3. Body: explain what and why, not how
```

**Don't:**
```markdown
Git stuff:
You should try to write good commit messages that follow
some basic principles like keeping them short but also
descriptive and using proper formatting...
```

#### Using Hierarchy

```markdown
# Code Style

## Java

### Formatting
- 4 spaces for indentation
- 140 character line limit

### Naming
- Classes: UpperCamelCase
- Methods: lowerCamelCase

## Python

### Formatting
- 4 spaces for indentation
- 88 character line limit (Black)
```

### Size Recommendations

| File Type | Recommended Size | Max Recommended |
|-----------|-----------------|-----------------|
| User global | 100-300 lines | 500 lines |
| Project | 200-500 lines | 1000 lines |
| Modular rule | 50-200 lines | 300 lines |

**Why limit size**: Large CLAUDE.md files consume context at startup, reducing space for code and conversation.

## Usage Patterns

### Basic Usage

#### Example 1: Personal Preferences

**File**: `~/.claude/CLAUDE.md`

```markdown
# Personal Preferences

## Git Commit Messages

Follow the Chris Beams guide:
1. Separate subject from body with blank line
2. Limit subject line to 50 characters
3. Capitalize the subject line
4. Do not end subject line with a period
5. Use imperative mood ("Add feature" not "Added feature")
6. Wrap body at 72 characters
7. Use body to explain what and why vs. how

## Communication Style

- Be concise and direct
- Focus on solutions, not problems
- Provide examples when explaining concepts
```

#### Example 2: Project Conventions

**File**: `.claude/CLAUDE.md`

```markdown
# Project Context

This is a Java-based distributed query engine (Trino).

## Code Style

Follow Trino project guidelines:
- 4 spaces for indentation (no tabs)
- 140 character line limit
- UpperCamelCase for classes, lowerCamelCase for methods
- No abbreviations except well-known (max, min, ttl)
- Avoid `var` for local variables
- Prefer Guava immutable collections

## Common Commands

- Build: `./mvnw clean install`
- Run tests: `./mvnw test`
- Format: `./mvnw spotless:apply`
- Single test: `./mvnw test -Dtest=TestClassName`

## Architecture

- Plugin-based architecture
- Each connector is a separate module
- SPIs in `trino-spi` module
```

#### Example 3: Modular Organization

**File Structure**:
```
.claude/
├── CLAUDE.md                 # Main project context
└── rules/
    ├── java-style.md         # Java coding standards
    ├── testing.md            # Testing conventions
    ├── git-workflow.md       # Git process
    └── security.md           # Security guidelines
```

**Main CLAUDE.md**:
```markdown
# Trino Project

Distributed SQL query engine written in Java.

## Quick Links

- Architecture: @docs/architecture.md
- Contributing: @CONTRIBUTING.md

## Key Points

- Performance is critical
- Backwards compatibility required
- Extensive test coverage mandatory

See `.claude/rules/` for detailed guidelines on code style, testing, and security.
```

**`.claude/rules/java-style.md`**:
```markdown
# Java Code Style

## Formatting
- 4 spaces for indentation
- Opening braces on same line
- 140 character line limit

## Naming Conventions
- Classes: UpperCamelCase
- Methods/variables: lowerCamelCase
- Constants: UPPER_SNAKE_CASE
- No abbreviations except: max, min, ttl, id, url
- Avoid "get" prefix: use specific verbs (find, fetch) or omit

## Imports
- No wildcard imports
- Static imports for: checkArgument, requireNonNull, format
- Group imports: Java stdlib, third-party, Trino
- Alphabetical within groups
```

### Advanced Usage

#### Conditional Rules with Frontmatter

**File**: `.claude/rules/frontend.md`

```markdown
---
paths:
  - "src/**/*.tsx"
  - "src/**/*.jsx"
description: React component guidelines
---

# React Component Guidelines

## Component Structure

```tsx
import { useState } from 'react';

interface Props {
  name: string;
  onUpdate: (value: string) => void;
}

export function ComponentName({ name, onUpdate }: Props) {
  const [state, setState] = useState('');

  return <div>{name}</div>;
}
```

## Best Practices

- Functional components with hooks only
- Named exports (not default exports)
- Props interface defined above component
- Use TypeScript, never PropTypes
```

**File**: `.claude/rules/backend.md`

```markdown
---
paths:
  - "src/main/java/**/*.java"
description: Java backend guidelines
---

# Java Backend Guidelines

## Error Handling

```java
public Result processData(String input) {
    requireNonNull(input, "input is null");
    checkArgument(!input.isEmpty(), "input is empty");

    try {
        return doProcess(input);
    }
    catch (IOException e) {
        throw new UncheckedIOException("Failed to process: " + input, e);
    }
}
```

## Logging

- Use slf4j via `@Log` annotation
- Log at appropriate level: DEBUG, INFO, WARN, ERROR
- Include context in log messages
```

#### Importing External Documentation

**File**: `.claude/CLAUDE.md`

```markdown
# Project Instructions

## Quick Reference

- API docs: @docs/api-reference.md
- Database schema: @docs/database-schema.md
- Deployment guide: @docs/deployment.md

## Code Style

Full Java style guide: @.claude/rules/java-style.md

## Testing

@.claude/rules/testing.md
```

This approach keeps CLAUDE.md concise while still providing comprehensive guidance.

#### Multi-Project Workspace

If you work on multiple projects in subdirectories:

```
~/work/
├── .claude/CLAUDE.md           # Work-wide conventions
├── project-a/
│   └── .claude/CLAUDE.md       # Project A specifics
└── project-b/
    └── .claude/CLAUDE.md       # Project B specifics
```

**`~/work/.claude/CLAUDE.md`** (shared):
```markdown
# Work Conventions

## All Projects

- Git commit format: Conventional Commits
- PR review required before merge
- All tests must pass before commit
```

**`~/work/project-a/.claude/CLAUDE.md`** (specific):
```markdown
# Project A - E-commerce API

Node.js + Express + PostgreSQL

## Commands

- Start dev: `npm run dev`
- Run tests: `npm test`
- Database migration: `npm run migrate`
```

When working in `~/work/project-a/`, Claude loads both files (work conventions + project specifics).

## Examples

### Example 1: Git Workflow Project

**File**: `.claude/CLAUDE.md`

```markdown
# Project Git Workflow

## Branch Naming

- Feature: `feature/short-description`
- Bug fix: `fix/issue-number-description`
- Refactor: `refactor/area-description`

## Commit Messages

Format: `type(scope): subject`

Types: feat, fix, refactor, test, docs, chore

Examples:
- `feat(auth): add OAuth2 support`
- `fix(api): handle null response in user endpoint`
- `refactor(db): extract query builders`

## Pull Requests

- Title: Same format as commit messages
- Description must include:
  - What changed
  - Why it changed
  - Testing performed
  - Screenshots (for UI changes)

## Code Review

Reviewers check for:
- Tests included and passing
- Documentation updated
- No commented-out code
- No console.log statements in production code
```

### Example 2: Trino Development

**File**: `.claude/CLAUDE.md`

```markdown
# Trino Development

Distributed SQL query engine written in Java.

## Code Style

Follow Trino project guidelines strictly.

### Guiding Principles
- **Readability first**: When readability and rules conflict, readability wins
- **Consistency**: Keep code consistent with surrounding code

### Formatting
- 4 spaces for indentation (no tabs)
- Opening braces on same line
- Line length limit of 140 characters
- Single blank line between methods

### Naming
- Classes: UpperCamelCase
- Methods/variables: lowerCamelCase
- Constants: UPPER_SNAKE_CASE
- **Avoid abbreviations**: No abbreviations except max, min, ttl
- **Avoid "get" prefix**: Use specific verbs (find, fetch) or omit entirely

### Imports
- No wildcard imports
- Static imports for: checkArgument, requireNonNull, format
- Group imports: Java stdlib, third-party, Trino
- Alphabetical order within groups

### Code Practices
- **Avoid `var`**: Do not use var for local variables
- Prefer `requireNonNull()` over manual null checks
- Use `checkArgument()` and `checkState()` for preconditions
- Mark fields as `private final` when possible
- **Prefer Guava immutable collections** over JDK unmodifiable collections
- **Use streams when appropriate**, but avoid in performance-sensitive sections
- **Prefer String formatting**: Use `format()` over concatenation
- **Avoid ternary operator** except for trivial expressions
- **Categorize exceptions**: Use appropriate error codes with TrinoException
- **Avoid default in enum switches**: Omit default to catch missing cases

### Testing
- **Avoid mocking libraries**: Write mocks by hand
- **Use AssertJ** for complex assertions
- **Maintain production quality** for test code

### Documentation
- Javadoc for public APIs
- Inline comments only when intent is not clear
- Focus on "why" rather than "what"

## Common Commands

- Build: `./mvnw clean install`
- Run tests: `./mvnw test`
- Single test: `./mvnw test -Dtest=TestClassName`
- Format code: `./mvnw spotless:apply`
- Checkstyle: `./mvnw checkstyle:check`

## Common Gotchas

- Spotless and Checkstyle must pass before commit
- Never commit with `var` in production code
- Always use static imports for checkArgument, requireNonNull
```

### Example 3: Frontend + Backend Monorepo

**File Structure**:
```
.claude/
├── CLAUDE.md                  # Project overview
└── rules/
    ├── frontend/
    │   ├── react.md
    │   └── styles.md
    └── backend/
        ├── java.md
        └── database.md
```

**`.claude/CLAUDE.md`**:
```markdown
# Full-Stack Application

Monorepo with React frontend and Java Spring backend.

## Project Structure

- `frontend/` - React + TypeScript
- `backend/` - Spring Boot + PostgreSQL
- `shared/` - Shared types and utilities

## Development Commands

- Start all: `docker-compose up`
- Frontend dev: `cd frontend && npm run dev`
- Backend dev: `cd backend && ./mvnw spring-boot:run`
- Run all tests: `./run-tests.sh`

## Detailed Guidelines

See `.claude/rules/` for language-specific conventions.
```

**`.claude/rules/frontend/react.md`**:
```markdown
---
paths:
  - "frontend/src/**/*.tsx"
  - "frontend/src/**/*.jsx"
---

# React Guidelines

## Component Structure

- Functional components only (no class components)
- Named exports (no default exports)
- Props interface defined above component
- Hooks at top of component function

## State Management

- Local state: useState
- Complex state: useReducer
- Global state: React Context
- Server state: React Query

## Styling

- Tailwind CSS utility classes
- No inline styles
- Component-specific styles in `.module.css`

## Testing

- Unit tests: Vitest
- Component tests: React Testing Library
- E2E tests: Playwright
```

**`.claude/rules/backend/java.md`**:
```markdown
---
paths:
  - "backend/src/**/*.java"
---

# Java Backend Guidelines

## Spring Boot Conventions

### Controllers

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    private final UserService userService;

    @Autowired
    public UserController(UserService userService) {
        this.userService = requireNonNull(userService, "userService is null");
    }

    @GetMapping("/{id}")
    public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
        return userService.findById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
}
```

### Services

- Constructor injection only (no field injection)
- Interface for each service
- Transaction boundaries at service layer
- Input validation with `requireNonNull` and `checkArgument`

### Repositories

- Extend JpaRepository
- Custom queries using @Query annotation
- Method naming conventions follow Spring Data JPA

## Error Handling

- Controller advice for global exception handling
- Custom exceptions extend RuntimeException
- Include error codes for client handling
```

### Example 4: API Documentation Standards

**File**: `.claude/CLAUDE.md`

```markdown
# API Documentation Standards

## Endpoint Documentation Format

Every endpoint must include:

```java
/**
 * Retrieves a user by ID.
 *
 * @param id the user ID (must be positive)
 * @return the user if found, 404 otherwise
 * @throws BadRequestException if id is invalid
 * @example
 *   GET /api/users/123
 *   Response: { "id": 123, "name": "John Doe", "email": "john@example.com" }
 */
@GetMapping("/users/{id}")
public ResponseEntity<User> getUser(@PathVariable Long id)
```

## OpenAPI/Swagger

- Use `@Operation` for endpoint descriptions
- Use `@ApiResponse` for response documentation
- Use `@Schema` for model documentation

Example:
```java
@Operation(summary = "Get user by ID", description = "Returns a single user")
@ApiResponses({
    @ApiResponse(responseCode = "200", description = "User found"),
    @ApiResponse(responseCode = "404", description = "User not found")
})
@GetMapping("/users/{id}")
public ResponseEntity<User> getUser(@PathVariable Long id)
```

## Response Format

All API responses follow this structure:

```json
{
  "data": { ... },          // Actual response data
  "meta": {                 // Metadata
    "timestamp": "2025-01-28T10:00:00Z",
    "version": "v1"
  }
}
```

Error responses:

```json
{
  "error": {
    "code": "USER_NOT_FOUND",
    "message": "User with ID 123 not found",
    "details": {}
  }
}
```
```

### Example 5: Security Guidelines

**File**: `.claude/rules/security.md`

```markdown
# Security Guidelines

## Input Validation

- Validate all user input at API boundaries
- Use allowlists, not denylists
- Sanitize input before database queries
- Never trust client-side validation alone

Example:
```java
public void updateEmail(String email) {
    checkArgument(email != null && email.matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$"),
                  "Invalid email format");
    // Process email
}
```

## SQL Injection Prevention

- Use parameterized queries (PreparedStatement)
- Never concatenate user input into SQL
- Use JPA/Hibernate for database access

**Bad**:
```java
String query = "SELECT * FROM users WHERE name = '" + userName + "'";
```

**Good**:
```java
String query = "SELECT * FROM users WHERE name = ?";
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setString(1, userName);
```

## Authentication & Authorization

- Use JWT tokens for API authentication
- Tokens expire after 1 hour
- Refresh tokens valid for 7 days
- Check permissions at method level with `@PreAuthorize`

## Secrets Management

- Never commit secrets to version control
- Use environment variables for configuration
- Rotate secrets regularly
- Use secret management service (AWS Secrets Manager, Vault)

## Sensitive Data

- Hash passwords with BCrypt (cost factor: 12)
- Encrypt PII at rest
- Mask sensitive data in logs
- Use HTTPS for all communication
```

## Best Practices

### Do's

1. **Keep it concise** - For each line, ask: "Would removing this cause Claude to make mistakes?" If not, cut it.

2. **Be specific** - "Use 2-space indentation" is better than "Format code properly"

3. **Use structure** - Organize with markdown headings and bullet points

4. **Include examples** - Show, don't just tell

5. **Focus on non-obvious info** - Include what Claude can't figure out from code

6. **Review regularly** - Update as your project evolves

7. **Use imports for organization** - Keep main CLAUDE.md short, import detailed docs

8. **Check into git** - Share with team for consistency

9. **Use modular rules** - Organize large projects into topic files

10. **Document commands** - Include non-obvious build/test/deploy commands

### Don'ts

1. **Don't duplicate code** - If it's in code, Claude can read it

2. **Don't write tutorials** - Link to external docs instead

3. **Don't include secrets** - Use environment variables

4. **Don't exceed 500 lines** - Split into modular rules instead

5. **Don't include frequently changing data** - (like current ticket assignments)

6. **Don't use vague language** - Be concrete and specific

7. **Don't overload with examples** - 1-2 good examples beat 10 mediocre ones

8. **Don't forget frontmatter** - Use conditional rules for large projects

## Common Patterns

### Pattern 1: Code Style + Commands

```markdown
# Project: ${PROJECT_NAME}

## Code Style
- Language: ${LANGUAGE}
- Indentation: ${INDENT_SIZE} spaces
- Line length: ${LINE_LENGTH} characters

## Common Commands
- Build: ${BUILD_COMMAND}
- Test: ${TEST_COMMAND}
- Format: ${FORMAT_COMMAND}
```

### Pattern 2: Multi-Language Project

```markdown
# Multi-Language Project

## Python (Backend)
@.claude/rules/python-style.md

## TypeScript (Frontend)
@.claude/rules/typescript-style.md

## SQL (Database)
@.claude/rules/sql-conventions.md
```

### Pattern 3: Monorepo with Workspaces

```markdown
# Monorepo Structure

- `packages/ui/` - React component library
- `apps/web/` - Next.js web app
- `apps/api/` - Express API server

## Workspace Commands

- Build all: `npm run build -ws`
- Test all: `npm test -ws`
- Add dependency: `npm install <pkg> -w <workspace>`

## Cross-Package Imports

Use workspace protocol: `"@myorg/ui": "workspace:*"`

See `.claude/rules/` for package-specific conventions.
```

### Pattern 4: Framework-Specific Conventions

```markdown
# Django Project Conventions

## App Structure

Each Django app follows:
```
app_name/
├── models.py           # Database models
├── views.py            # View logic
├── serializers.py      # DRF serializers
├── urls.py             # URL routing
├── admin.py            # Admin interface
└── tests/
    ├── test_models.py
    ├── test_views.py
    └── test_serializers.py
```

## Model Conventions

- Use `created_at` and `updated_at` fields
- Override `__str__` for readable representation
- Use `Meta.ordering` for default sort
- Add `verbose_name` and `verbose_name_plural`

## View Conventions

- Class-based views for CRUD
- Function-based views for simple operations
- Use DRF ViewSets for APIs
- Include docstrings explaining business logic
```

### Pattern 5: Testing Conventions

```markdown
# Testing Conventions

## Test Organization

```
tests/
├── unit/              # Fast, isolated tests
├── integration/       # Tests with database
└── e2e/              # End-to-end tests
```

## Test Naming

- Test files: `test_<module>.py`
- Test classes: `Test<ClassName>`
- Test methods: `test_<what>_<condition>_<expected>`

Example: `test_user_login_invalid_password_returns_401`

## Test Structure (AAA Pattern)

```python
def test_user_creation_with_valid_data_succeeds():
    # Arrange
    user_data = {"email": "test@example.com", "password": "secure123"}

    # Act
    user = create_user(user_data)

    # Assert
    assert user.email == "test@example.com"
    assert user.password_hash is not None
```

## Coverage Requirements

- Minimum 80% line coverage
- 100% coverage for critical paths (auth, payments)
- Run: `pytest --cov=src tests/`
```

## Gotchas and Troubleshooting

### Common Issues

#### Issue 1: CLAUDE.md Changes Not Applied

**Symptoms**: You edit CLAUDE.md but Claude doesn't follow new instructions.

**Cause**: CLAUDE.md is loaded at session startup only.

**Solution**:
```bash
# Option 1: Start new session
exit  # or Ctrl+D
claude

# Option 2: Use /memory command
/memory  # Edit and save to reload
```

#### Issue 2: Instructions Being Ignored

**Symptoms**: Claude doesn't follow instructions in CLAUDE.md.

**Cause**: Instructions too vague, buried in long file, or contradictory.

**Solutions**:
- Make instructions specific and concrete
- Use bullet points and clear headings
- Put most important instructions at the top
- Check for contradictions between user/project CLAUDE.md

#### Issue 3: CLAUDE.md Too Large

**Symptoms**: Context fills up quickly, little room for code/conversation.

**Cause**: CLAUDE.md exceeds 500 lines.

**Solutions**:
1. **Use modular rules**: Split into `.claude/rules/*.md`
2. **Use imports**: Move detailed docs to separate files
3. **Remove redundant info**: Claude can infer from code
4. **Summarize**: Link to full docs instead of copying

#### Issue 4: Import Path Not Found

**Symptoms**: `@path/to/file.md` not loading.

**Cause**: Incorrect path, file doesn't exist, or circular import.

**Solutions**:
- Verify file exists: `ls -la path/to/file.md`
- Check path relative to CLAUDE.md location
- Use absolute path: `@~/full/path/to/file.md`
- Check for circular imports (A imports B, B imports A)

#### Issue 5: Team Member Sees Different Behavior

**Symptoms**: Claude behaves differently for different team members.

**Cause**: Personal CLAUDE.md overriding project CLAUDE.md.

**Solution**: Check personal file at `~/.claude/CLAUDE.md` - it overrides project settings.

#### Issue 6: Git Secrets Accidentally Committed

**Symptoms**: Sensitive data in CLAUDE.md committed to version control.

**Prevention**:
```bash
# Add to .gitignore before committing
echo "CLAUDE.local.md" >> .gitignore
echo ".claude/CLAUDE.local.md" >> .gitignore
```

**Remediation** (if already committed):
```bash
# Remove from history (use BFG Repo-Cleaner or git-filter-repo)
git filter-repo --path .claude/CLAUDE.md --invert-paths
git push --force
```

Then update CLAUDE.md without secrets and use environment variables.

### Debugging

#### Check What's Loaded

Unfortunately, there's no built-in command to show exactly what CLAUDE.md content was loaded. Best practices:

1. **Test in isolation**: Create a minimal test session to verify behavior
2. **Use clear markers**: Add unique text to different CLAUDE.md files to identify which is being applied
3. **Simplify**: Temporarily remove sections to identify problematic instructions

#### Verify File Priority

Test which file takes priority:

```bash
# User-level
echo "# User Level Test" >> ~/.claude/CLAUDE.md

# Project-level
echo "# Project Level Test" >> .claude/CLAUDE.md

# Local-level
echo "# Local Level Test" >> .claude/CLAUDE.local.md

# Start session and ask: "What test levels do you see in CLAUDE.md?"
```

Claude should respond with all three, with local overriding project overriding user.

### Limitations

1. **No mid-session reload**: Changes require restart or `/memory` edit
2. **Context consumption**: Large CLAUDE.md files use context, leaving less for code
3. **No conditional logic**: Can't write "if Python project, do X; if Java, do Y" (use conditional rules instead)
4. **No variable substitution**: Can't use `${PROJECT_NAME}` variables (except in imports)
5. **No includes at runtime**: All imports resolved at startup
6. **No access to environment variables**: Can't reference `$ENV_VAR` in CLAUDE.md

## API Reference

### YAML Frontmatter

Used in modular rules for conditional application.

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `paths` | string[] | No | Glob patterns for files this rule applies to |
| `description` | string | No | Human-readable description of the rule |

**Example**:
```yaml
---
paths:
  - "src/**/*.py"
  - "tests/**/*.py"
description: Python code style guidelines
---
```

### Import Syntax

Format: `@path/to/file.md`

**Supported paths**:
- Relative: `@docs/api.md` (relative to CLAUDE.md containing import)
- Absolute: `@/full/path/to/file.md`
- Tilde: `@~/path/from/home.md`

**Behavior**:
- Imports are recursive (imported files can import others)
- Circular imports are prevented
- Missing files cause warnings but don't fail session startup

### File Name Conventions

| File | Purpose | Auto-loaded? | Scope |
|------|---------|--------------|-------|
| `CLAUDE.md` | Project root memory | Yes (if in cwd or parents) | Project |
| `.claude/CLAUDE.md` | Project organized memory | Yes | Project |
| `CLAUDE.local.md` | Personal project overrides | Yes | Local only |
| `.claude/CLAUDE.local.md` | Personal organized overrides | Yes | Local only |
| `.claude/rules/*.md` | Modular project rules | Yes | Project |
| Any other `*.md` | Supporting documentation | No (unless imported) | N/A |

## Related Features

### Skills
CLAUDE.md provides persistent context, while Skills package workflows and domain knowledge. Use CLAUDE.md to set coding standards, Skills to implement repeatable tasks applying those standards.

**Example**: CLAUDE.md defines API documentation format, `/api-doc` Skill generates docs following that format.

### Subagents
Subagents can preload Skills, which can reference CLAUDE.md context. Use CLAUDE.md for project-wide conventions that subagents should follow.

**Example**: CLAUDE.md defines code review criteria, code-reviewer subagent applies those criteria.

### Hooks
Hooks can validate that changes follow CLAUDE.md guidelines. Use CLAUDE.md for instructions, Hooks for enforcement.

**Example**: CLAUDE.md says "format with Prettier", PostToolUse Hook runs Prettier automatically.

### Output Styles
Output Styles change how Claude responds, while CLAUDE.md provides persistent facts. Combine for consistent formatting of specific content.

**Example**: CLAUDE.md defines commit message format, Output Style ensures explanations are concise.

## Additional Resources

- **Official Documentation**: https://docs.anthropic.com/claude/docs/claude-code#memory
- **Claude Code GitHub**: https://github.com/anthropics/claude-code
- **Best Practices**: https://docs.anthropic.com/claude/docs/claude-code-tips
- **Community Examples**: https://github.com/topics/claude-code

## Changelog

### January 2025
- Added conditional rules with frontmatter
- Added modular rules support (`.claude/rules/`)
- Improved import syntax documentation
- Added CLAUDE.local.md for personal overrides

### Earlier Features
- Basic CLAUDE.md loading from project root
- Hierarchical loading (user -> project)
- Import syntax with `@path/to/file`
- Multiple file location support

---

**Next**: Learn about [Skills](./2.%20Skills.md) to create reusable workflows that leverage your CLAUDE.md context.
